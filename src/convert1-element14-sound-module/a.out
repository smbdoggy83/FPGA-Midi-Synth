-- This VHDL was converted from Verilog using the
-- Icarus Verilog VHDL Code Generator 12.0 (devel) (s20150603-1110-g18392a46)

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Generated from Verilog module SoundModule (SoundModule.v:1)
entity SoundModule is
  port (
    CLOCK_50 : in std_logic;
    I2S_BIT_CLOCK : out std_logic;
    I2S_LEFT_RIGHT_SELECT : out std_logic;
    I2S_SOUND_DATA : out std_logic;
    LED : out unsigned(7 downto 0);
    MIDI_RX : in std_logic
  );
end entity; 

-- Generated from Verilog module SoundModule (SoundModule.v:1)
architecture from_verilog of SoundModule is
  signal I2S_BIT_CLOCK_Reg : std_logic;
  signal I2S_LEFT_RIGHT_SELECT_Reg : std_logic;
  signal I2S_SOUND_DATA_Reg : std_logic;
  signal LED_Reg : unsigned(7 downto 0);
  signal i2sBitClock : std_logic;  -- Declared at SoundModule.v:10
  signal i2sLeftRightSelect : std_logic;  -- Declared at SoundModule.v:12
  signal i2sSoundData : std_logic;  -- Declared at SoundModule.v:11
  signal isNoteOn : std_logic;  -- Declared at SoundModule.v:14
  signal modulationValue : unsigned(7 downto 0);  -- Declared at SoundModule.v:16
  signal noteSampleTicks : unsigned(23 downto 0);  -- Declared at SoundModule.v:15
  
  component MidiProcessor is
    port (
      CLOCK_50 : in std_logic;
      MIDI_RX : in std_logic;
      isNoteOn : out std_logic;
      modulationValue : out unsigned(7 downto 0);
      noteSampleTicks : out unsigned(23 downto 0)
    );
  end component;
  
  component Synthesizer is
    port (
      CLOCK_50 : inout std_logic;
      i2sBitClock : out std_logic;
      i2sLeftRightSelect : out std_logic;
      i2sSoundData : out std_logic;
      isNoteOn : in std_logic;
      modulationValue : in unsigned(7 downto 0);
      noteSampleTicks : in unsigned(23 downto 0)
    );
  end component;
begin
  I2S_BIT_CLOCK <= I2S_BIT_CLOCK_Reg;
  I2S_LEFT_RIGHT_SELECT <= I2S_LEFT_RIGHT_SELECT_Reg;
  I2S_SOUND_DATA <= I2S_SOUND_DATA_Reg;
  LED <= LED_Reg;
  
  -- Generated from instantiation at SoundModule.v:18
  midiProcessor_inst: MidiProcessor
    port map (
      CLOCK_50 => CLOCK_50,
      MIDI_RX => MIDI_RX,
      isNoteOn => isNoteOn,
      modulationValue => modulationValue,
      noteSampleTicks => noteSampleTicks
    );
  
  -- Generated from instantiation at SoundModule.v:19
  synthesizer_inst: Synthesizer
    port map (
      CLOCK_50 => CLOCK_50,
      i2sBitClock => i2sBitClock,
      i2sLeftRightSelect => i2sLeftRightSelect,
      i2sSoundData => i2sSoundData,
      isNoteOn => isNoteOn,
      modulationValue => modulationValue,
      noteSampleTicks => noteSampleTicks
    );
  
  -- Generated from always process in SoundModule (SoundModule.v:21)
  process (CLOCK_50) is
  begin
    if rising_edge(CLOCK_50) then
      I2S_BIT_CLOCK_Reg <= i2sBitClock;
      I2S_SOUND_DATA_Reg <= i2sSoundData;
      I2S_LEFT_RIGHT_SELECT_Reg <= i2sLeftRightSelect;
      if isNoteOn = '1' then
        LED_Reg <= noteSampleTicks(0 + 7 downto 0);
      else
        LED_Reg <= X"00";
      end if;
    end if;
  end process;
end architecture;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Generated from Verilog module MidiProcessor (MidiProcessor.v:1)
entity MidiProcessor is
  port (
    CLOCK_50 : in std_logic;
    MIDI_RX : in std_logic;
    isNoteOn : out std_logic;
    modulationValue : out unsigned(7 downto 0);
    noteSampleTicks : out unsigned(23 downto 0)
  );
end entity; 

-- Generated from Verilog module MidiProcessor (MidiProcessor.v:1)
architecture from_verilog of MidiProcessor is
  signal isNoteOn_Reg : std_logic;
  signal modulationValue_Reg : unsigned(7 downto 0);
  signal noteSampleTicks_Reg : unsigned(23 downto 0);
  signal byteValue : unsigned(7 downto 0);  -- Declared at MidiProcessor.v:20
  signal channel : unsigned(3 downto 0) := X"0";  -- Declared at MidiProcessor.v:10
  signal controllerNumber : unsigned(7 downto 0) := X"00";  -- Declared at MidiProcessor.v:17
  signal dataByte0 : unsigned(7 downto 0) := X"00";  -- Declared at MidiProcessor.v:11
  signal dataByte1 : unsigned(7 downto 0) := X"00";  -- Declared at MidiProcessor.v:12
  signal dataByte2 : unsigned(7 downto 0) := X"00";  -- Declared at MidiProcessor.v:13
  signal dataBytesReceivedCount : unsigned(7 downto 0) := X"00";  -- Declared at MidiProcessor.v:14
  signal isByteAvailable : std_logic;  -- Declared at MidiProcessor.v:19
  signal isDataByteAvailable : std_logic := '0';  -- Declared at MidiProcessor.v:15
  signal midiNoteNumber : unsigned(7 downto 0) := X"00";  -- Declared at MidiProcessor.v:16
  signal sampleTicks : unsigned(23 downto 0);  -- Declared at MidiProcessor.v:21
  signal status : unsigned(3 downto 0) := X"0";  -- Declared at MidiProcessor.v:9
  
  component MidiByteReader is
    port (
      CLOCK_50 : in std_logic;
      MIDI_RX : in std_logic;
      byteValue : out unsigned(7 downto 0);
      isByteAvailable : out std_logic
    );
  end component;
  
  component MidiNoteNumberToSampleTicks is
    port (
      midiNoteNumber : in unsigned(7 downto 0);
      noteSampleTicks : out unsigned(23 downto 0)
    );
  end component;
begin
  isNoteOn <= isNoteOn_Reg;
  modulationValue <= modulationValue_Reg;
  noteSampleTicks <= noteSampleTicks_Reg;
  
  -- Generated from instantiation at MidiProcessor.v:23
  midiByteReader_inst: MidiByteReader
    port map (
      CLOCK_50 => CLOCK_50,
      MIDI_RX => MIDI_RX,
      byteValue => byteValue,
      isByteAvailable => isByteAvailable
    );
  
  -- Generated from instantiation at MidiProcessor.v:24
  midiNoteNumberToSampleTicks_inst: MidiNoteNumberToSampleTicks
    port map (
      midiNoteNumber => midiNoteNumber,
      noteSampleTicks => sampleTicks
    );
  -- Removed one empty process
  
  
  -- Generated from always process in MidiProcessor (MidiProcessor.v:26)
  process (CLOCK_50) is
  begin
    if rising_edge(CLOCK_50) then
      if isByteAvailable = '1' then
        if byteValue < X"80" then
          case dataBytesReceivedCount is
            when X"00" =>
              dataByte0 <= byteValue;
              dataBytesReceivedCount <= X"01";
              isDataByteAvailable <= '1';
            when X"01" =>
              dataByte1 <= byteValue;
              dataBytesReceivedCount <= X"02";
              isDataByteAvailable <= '1';
            when X"02" =>
              dataByte2 <= byteValue;
              dataBytesReceivedCount <= X"03";
              isDataByteAvailable <= '1';
            when others =>
              null;
          end case;
        else
          status <= byteValue(4 + 3 downto 4);
          channel <= byteValue(0 + 3 downto 0);
          dataBytesReceivedCount <= X"00";
        end if;
      else
        if isDataByteAvailable = '1' then
          isDataByteAvailable <= '0';
          case status is
            when X"8" =>
              if Resize(dataBytesReceivedCount, 32) = X"00000002" then
                if midiNoteNumber = dataByte0 then
                  dataBytesReceivedCount <= X"00";
                  isNoteOn_Reg <= '0';
                end if;
              end if;
            when X"9" =>
              case dataBytesReceivedCount is
                when X"01" =>
                  midiNoteNumber <= dataByte0;
                when X"02" =>
                  dataBytesReceivedCount <= X"00";
                  if Resize(dataByte1, 32) = X"00000000" then
                    isNoteOn_Reg <= '0';
                  else
                    isNoteOn_Reg <= '1';
                    noteSampleTicks_Reg <= sampleTicks;
                  end if;
                when others =>
                  null;
              end case;
            when X"b" =>
              case dataBytesReceivedCount is
                when X"01" =>
                  controllerNumber <= dataByte0;
                when X"02" =>
                  if controllerNumber = X"01" then
                    dataBytesReceivedCount <= X"00";
                    modulationValue_Reg <= dataByte1;
                  end if;
                when others =>
                  null;
              end case;
            when others =>
              null;
          end case;
        end if;
      end if;
    end if;
  end process;
end architecture;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Generated from Verilog module MidiByteReader (MidiByteReader.v:1)
--   debounceTicks = 10
--   midiTicks = 1600
--   stateByteComplete = 2
--   stateSignalAvailable = 1
--   stateWaitingForSignal = 0
entity MidiByteReader is
  port (
    CLOCK_50 : in std_logic;
    MIDI_RX : in std_logic;
    byteValue : out unsigned(7 downto 0);
    isByteAvailable : out std_logic
  );
end entity; 

-- Generated from Verilog module MidiByteReader (MidiByteReader.v:1)
--   debounceTicks = 10
--   midiTicks = 1600
--   stateByteComplete = 2
--   stateSignalAvailable = 1
--   stateWaitingForSignal = 0
architecture from_verilog of MidiByteReader is
  signal byteValue_Reg : unsigned(7 downto 0);
  signal isByteAvailable_Reg : std_logic;
  signal bitNumber : unsigned(7 downto 0) := X"00";  -- Declared at MidiByteReader.v:18
  signal debounceCountDown : unsigned(7 downto 0) := X"0a";  -- Declared at MidiByteReader.v:20
  signal midiCount : unsigned(11 downto 0) := X"000";  -- Declared at MidiByteReader.v:19
  signal midiState : unsigned(7 downto 0) := X"00";  -- Declared at MidiByteReader.v:17
begin
  byteValue <= byteValue_Reg;
  isByteAvailable <= isByteAvailable_Reg;
  
  -- Generated from initial process in MidiByteReader (MidiByteReader.v:1)
  process is
  begin
    isByteAvailable_Reg <= '0';
    byteValue_Reg <= X"00";
    wait;
  end process;
  
  -- Generated from always process in MidiByteReader (MidiByteReader.v:22)
  process (CLOCK_50) is
  begin
    if rising_edge(CLOCK_50) then
      case midiState is
        when X"00" =>
          isByteAvailable_Reg <= '0';
          if MIDI_RX = '0' then
            debounceCountDown <= debounceCountDown - X"01";
            if debounceCountDown = X"00" then
              debounceCountDown <= X"0a";
              midiState <= X"01";
              midiCount <= X"000";
              bitNumber <= X"00";
              byteValue_Reg <= X"00";
            end if;
          else
            debounceCountDown <= X"0a";
          end if;
        when X"01" =>
          midiCount <= midiCount + X"001";
          if midiCount = X"640" then
            midiCount <= X"000";
            bitNumber <= bitNumber + X"01";
            if MIDI_RX = '1' then
              byteValue_Reg <= byteValue_Reg or (X"01" sll To_Integer(bitNumber));
            end if;
            if bitNumber = X"07" then
              midiState <= X"02";
            end if;
          end if;
        when X"02" =>
          midiCount <= midiCount + X"001";
          if midiCount = X"640" then
            isByteAvailable_Reg <= '1';
            midiState <= X"00";
          end if;
        when others =>
          null;
      end case;
    end if;
  end process;
end architecture;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Generated from Verilog module MidiNoteNumberToSampleTicks (MidiNoteNumberToSampleTicks.v:1)
entity MidiNoteNumberToSampleTicks is
  port (
    midiNoteNumber : in unsigned(7 downto 0);
    noteSampleTicks : out unsigned(23 downto 0)
  );
end entity; 

-- Generated from Verilog module MidiNoteNumberToSampleTicks (MidiNoteNumberToSampleTicks.v:1)
architecture from_verilog of MidiNoteNumberToSampleTicks is
  signal noteSampleTicks_Reg : unsigned(23 downto 0);
begin
  noteSampleTicks <= noteSampleTicks_Reg;
  
  -- Generated from always process in MidiNoteNumberToSampleTicks (MidiNoteNumberToSampleTicks.v:6)
  process (midiNoteNumber) is
  begin
    case midiNoteNumber is
      when X"00" =>
        noteSampleTicks_Reg <= X"005d51";
      when X"01" =>
        noteSampleTicks_Reg <= X"005814";
      when X"02" =>
        noteSampleTicks_Reg <= X"005322";
      when X"03" =>
        noteSampleTicks_Reg <= X"004e78";
      when X"04" =>
        noteSampleTicks_Reg <= X"004a10";
      when X"05" =>
        noteSampleTicks_Reg <= X"0045e8";
      when X"06" =>
        noteSampleTicks_Reg <= X"0041fc";
      when X"07" =>
        noteSampleTicks_Reg <= X"003e48";
      when X"08" =>
        noteSampleTicks_Reg <= X"003ac9";
      when X"09" =>
        noteSampleTicks_Reg <= X"00377c";
      when X"0a" =>
        noteSampleTicks_Reg <= X"00345f";
      when X"0b" =>
        noteSampleTicks_Reg <= X"00316e";
      when X"0c" =>
        noteSampleTicks_Reg <= X"002ea8";
      when X"0d" =>
        noteSampleTicks_Reg <= X"002c0a";
      when X"0e" =>
        noteSampleTicks_Reg <= X"002991";
      when X"0f" =>
        noteSampleTicks_Reg <= X"00273c";
      when X"10" =>
        noteSampleTicks_Reg <= X"002508";
      when X"11" =>
        noteSampleTicks_Reg <= X"0022f4";
      when X"12" =>
        noteSampleTicks_Reg <= X"0020fe";
      when X"13" =>
        noteSampleTicks_Reg <= X"001f24";
      when X"14" =>
        noteSampleTicks_Reg <= X"001d64";
      when X"15" =>
        noteSampleTicks_Reg <= X"001bbe";
      when X"16" =>
        noteSampleTicks_Reg <= X"001a2f";
      when X"17" =>
        noteSampleTicks_Reg <= X"0018b7";
      when X"18" =>
        noteSampleTicks_Reg <= X"001754";
      when X"19" =>
        noteSampleTicks_Reg <= X"001605";
      when X"1a" =>
        noteSampleTicks_Reg <= X"0014c8";
      when X"1b" =>
        noteSampleTicks_Reg <= X"00139e";
      when X"1c" =>
        noteSampleTicks_Reg <= X"001284";
      when X"1d" =>
        noteSampleTicks_Reg <= X"00117a";
      when X"1e" =>
        noteSampleTicks_Reg <= X"00107f";
      when X"1f" =>
        noteSampleTicks_Reg <= X"000f92";
      when X"20" =>
        noteSampleTicks_Reg <= X"000eb2";
      when X"21" =>
        noteSampleTicks_Reg <= X"000ddf";
      when X"22" =>
        noteSampleTicks_Reg <= X"000d17";
      when X"23" =>
        noteSampleTicks_Reg <= X"000c5b";
      when X"24" =>
        noteSampleTicks_Reg <= X"000baa";
      when X"25" =>
        noteSampleTicks_Reg <= X"000b02";
      when X"26" =>
        noteSampleTicks_Reg <= X"000a64";
      when X"27" =>
        noteSampleTicks_Reg <= X"0009cf";
      when X"28" =>
        noteSampleTicks_Reg <= X"000942";
      when X"29" =>
        noteSampleTicks_Reg <= X"0008bd";
      when X"2a" =>
        noteSampleTicks_Reg <= X"00083f";
      when X"2b" =>
        noteSampleTicks_Reg <= X"0007c9";
      when X"2c" =>
        noteSampleTicks_Reg <= X"000759";
      when X"2d" =>
        noteSampleTicks_Reg <= X"0006ef";
      when X"2e" =>
        noteSampleTicks_Reg <= X"00068b";
      when X"2f" =>
        noteSampleTicks_Reg <= X"00062d";
      when X"30" =>
        noteSampleTicks_Reg <= X"0005d5";
      when X"31" =>
        noteSampleTicks_Reg <= X"000581";
      when X"32" =>
        noteSampleTicks_Reg <= X"000532";
      when X"33" =>
        noteSampleTicks_Reg <= X"0004e7";
      when X"34" =>
        noteSampleTicks_Reg <= X"0004a1";
      when X"35" =>
        noteSampleTicks_Reg <= X"00045e";
      when X"36" =>
        noteSampleTicks_Reg <= X"00041f";
      when X"37" =>
        noteSampleTicks_Reg <= X"0003e4";
      when X"38" =>
        noteSampleTicks_Reg <= X"0003ac";
      when X"39" =>
        noteSampleTicks_Reg <= X"000377";
      when X"3a" =>
        noteSampleTicks_Reg <= X"000345";
      when X"3b" =>
        noteSampleTicks_Reg <= X"000316";
      when X"3c" =>
        noteSampleTicks_Reg <= X"0002ea";
      when X"3d" =>
        noteSampleTicks_Reg <= X"0002c0";
      when X"3e" =>
        noteSampleTicks_Reg <= X"000299";
      when X"3f" =>
        noteSampleTicks_Reg <= X"000273";
      when X"40" =>
        noteSampleTicks_Reg <= X"000250";
      when X"41" =>
        noteSampleTicks_Reg <= X"00022f";
      when X"42" =>
        noteSampleTicks_Reg <= X"00020f";
      when X"43" =>
        noteSampleTicks_Reg <= X"0001f2";
      when X"44" =>
        noteSampleTicks_Reg <= X"0001d6";
      when X"45" =>
        noteSampleTicks_Reg <= X"0001bb";
      when X"46" =>
        noteSampleTicks_Reg <= X"0001a2";
      when X"47" =>
        noteSampleTicks_Reg <= X"00018b";
      when X"48" =>
        noteSampleTicks_Reg <= X"000175";
      when X"49" =>
        noteSampleTicks_Reg <= X"000160";
      when X"4a" =>
        noteSampleTicks_Reg <= X"00014c";
      when X"4b" =>
        noteSampleTicks_Reg <= X"000139";
      when X"4c" =>
        noteSampleTicks_Reg <= X"000128";
      when X"4d" =>
        noteSampleTicks_Reg <= X"000117";
      when X"4e" =>
        noteSampleTicks_Reg <= X"000107";
      when X"4f" =>
        noteSampleTicks_Reg <= X"0000f9";
      when X"50" =>
        noteSampleTicks_Reg <= X"0000eb";
      when X"51" =>
        noteSampleTicks_Reg <= X"0000dd";
      when X"52" =>
        noteSampleTicks_Reg <= X"0000d1";
      when X"53" =>
        noteSampleTicks_Reg <= X"0000c5";
      when X"54" =>
        noteSampleTicks_Reg <= X"0000ba";
      when X"55" =>
        noteSampleTicks_Reg <= X"0000b0";
      when X"56" =>
        noteSampleTicks_Reg <= X"0000a6";
      when X"57" =>
        noteSampleTicks_Reg <= X"00009c";
      when X"58" =>
        noteSampleTicks_Reg <= X"000094";
      when X"59" =>
        noteSampleTicks_Reg <= X"00008b";
      when X"5a" =>
        noteSampleTicks_Reg <= X"000083";
      when X"5b" =>
        noteSampleTicks_Reg <= X"00007c";
      when X"5c" =>
        noteSampleTicks_Reg <= X"000075";
      when X"5d" =>
        noteSampleTicks_Reg <= X"00006e";
      when X"5e" =>
        noteSampleTicks_Reg <= X"000068";
      when X"5f" =>
        noteSampleTicks_Reg <= X"000062";
      when X"60" =>
        noteSampleTicks_Reg <= X"00005d";
      when X"61" =>
        noteSampleTicks_Reg <= X"000058";
      when X"62" =>
        noteSampleTicks_Reg <= X"000053";
      when X"63" =>
        noteSampleTicks_Reg <= X"00004e";
      when X"64" =>
        noteSampleTicks_Reg <= X"00004a";
      when X"65" =>
        noteSampleTicks_Reg <= X"000045";
      when X"66" =>
        noteSampleTicks_Reg <= X"000041";
      when X"67" =>
        noteSampleTicks_Reg <= X"00003e";
      when X"68" =>
        noteSampleTicks_Reg <= X"00003a";
      when X"69" =>
        noteSampleTicks_Reg <= X"000037";
      when X"6a" =>
        noteSampleTicks_Reg <= X"000034";
      when X"6b" =>
        noteSampleTicks_Reg <= X"000031";
      when X"6c" =>
        noteSampleTicks_Reg <= X"00002e";
      when X"6d" =>
        noteSampleTicks_Reg <= X"00002c";
      when X"6e" =>
        noteSampleTicks_Reg <= X"000029";
      when X"6f" =>
        noteSampleTicks_Reg <= X"000027";
      when X"70" =>
        noteSampleTicks_Reg <= X"000025";
      when X"71" =>
        noteSampleTicks_Reg <= X"000022";
      when X"72" =>
        noteSampleTicks_Reg <= X"000020";
      when X"73" =>
        noteSampleTicks_Reg <= X"00001f";
      when X"74" =>
        noteSampleTicks_Reg <= X"00001d";
      when X"75" =>
        noteSampleTicks_Reg <= X"00001b";
      when X"76" =>
        noteSampleTicks_Reg <= X"00001a";
      when X"77" =>
        noteSampleTicks_Reg <= X"000018";
      when X"78" =>
        noteSampleTicks_Reg <= X"000017";
      when X"79" =>
        noteSampleTicks_Reg <= X"000016";
      when X"7a" =>
        noteSampleTicks_Reg <= X"000014";
      when X"7b" =>
        noteSampleTicks_Reg <= X"000013";
      when X"7c" =>
        noteSampleTicks_Reg <= X"000012";
      when X"7d" =>
        noteSampleTicks_Reg <= X"000011";
      when X"7e" =>
        noteSampleTicks_Reg <= X"000010";
      when X"7f" =>
        noteSampleTicks_Reg <= X"00000f";
      when others =>
        noteSampleTicks_Reg <= X"000000";
    end case;
  end process;
end architecture;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Generated from Verilog module Synthesizer (Synthesizer.v:1)
--   i2sTicks = 18
entity Synthesizer is
  port (
    CLOCK_50 : inout std_logic;
    i2sBitClock : out std_logic;
    i2sLeftRightSelect : out std_logic;
    i2sSoundData : out std_logic;
    isNoteOn : in std_logic;
    modulationValue : in unsigned(7 downto 0);
    noteSampleTicks : in unsigned(23 downto 0)
  );
end entity; 

-- Generated from Verilog module Synthesizer (Synthesizer.v:1)
--   i2sTicks = 18
architecture from_verilog of Synthesizer is
  signal i2sBitClock_Reg : std_logic;
  signal i2sLeftRightSelect_Reg : std_logic;
  signal i2sSoundData_Reg : std_logic;
  signal bitCount : unsigned(7 downto 0) := X"0f";  -- Declared at Synthesizer.v:16
  signal i2sCount : unsigned(11 downto 0) := X"000";  -- Declared at Synthesizer.v:14
  signal isSamplePlaying : std_logic := '0';  -- Declared at Synthesizer.v:20
  signal isSoundPlaying : std_logic := '0';  -- Declared at Synthesizer.v:21
  signal modulation : unsigned(7 downto 0) := X"00";  -- Declared at Synthesizer.v:19
  signal noteSampleCount : unsigned(23 downto 0) := X"000000";  -- Declared at Synthesizer.v:15
  signal renderedSample : unsigned(15 downto 0);  -- Declared at Synthesizer.v:26
  signal sampleIndex : unsigned(7 downto 0) := X"00";  -- Declared at Synthesizer.v:17
  signal waveTableIndex : unsigned(7 downto 0) := X"00";  -- Declared at Synthesizer.v:18
  signal waveTableSample0 : unsigned(15 downto 0);  -- Declared at Synthesizer.v:23
  signal waveTableSample1 : unsigned(15 downto 0);  -- Declared at Synthesizer.v:24
  signal waveTableSample2 : unsigned(15 downto 0);  -- Declared at Synthesizer.v:25
  
  component SampleMixer is
    port (
      modulationValue : in unsigned(7 downto 0);
      renderedSample : out unsigned(15 downto 0);
      sample0 : in unsigned(15 downto 0);
      sample1 : in unsigned(15 downto 0);
      sample2 : in unsigned(15 downto 0)
    );
  end component;
  
  component WaveTable0Rom is
    port (
      address : in unsigned(7 downto 0);
      clock : inout std_logic;
      q : out unsigned(15 downto 0)
    );
  end component;
  
  component WaveTable1Rom is
    port (
      address : in unsigned(7 downto 0);
      clock : inout std_logic;
      q : out unsigned(15 downto 0)
    );
  end component;
  
  component WaveTable2Rom is
    port (
      address : in unsigned(7 downto 0);
      clock : inout std_logic;
      q : out unsigned(15 downto 0)
    );
  end component;
begin
  i2sBitClock <= i2sBitClock_Reg;
  i2sLeftRightSelect <= i2sLeftRightSelect_Reg;
  i2sSoundData <= i2sSoundData_Reg;
  
  -- Generated from instantiation at Synthesizer.v:32
  sampleMixer_inst: SampleMixer
    port map (
      modulationValue => modulation,
      renderedSample => renderedSample,
      sample0 => waveTableSample0,
      sample1 => waveTableSample1,
      sample2 => waveTableSample2
    );
  
  -- Generated from instantiation at Synthesizer.v:28
  waveTable0Rom_inst: WaveTable0Rom
    port map (
      address => waveTableIndex,
      clock => CLOCK_50,
      q => waveTableSample0
    );
  
  -- Generated from instantiation at Synthesizer.v:29
  waveTable1Rom_inst: WaveTable1Rom
    port map (
      address => waveTableIndex,
      clock => CLOCK_50,
      q => waveTableSample1
    );
  
  -- Generated from instantiation at Synthesizer.v:30
  waveTable2Rom_inst: WaveTable2Rom
    port map (
      address => waveTableIndex,
      clock => CLOCK_50,
      q => waveTableSample2
    );
  -- Removed one empty process
  
  
  -- Generated from always process in Synthesizer (Synthesizer.v:34)
  process (CLOCK_50) is
  begin
    if rising_edge(CLOCK_50) then
      i2sCount <= i2sCount + X"001";
      if i2sCount = X"012" then
        i2sCount <= X"000";
        i2sBitClock_Reg <= not i2sBitClock_Reg;
        if i2sBitClock_Reg = '1' then
          if isSoundPlaying = '1' then
            i2sSoundData_Reg <= renderedSample(To_Integer(bitCount));
          else
            i2sSoundData_Reg <= '0';
          end if;
          if Resize(bitCount, 32) = X"00000000" then
            i2sLeftRightSelect_Reg <= not i2sLeftRightSelect_Reg;
            bitCount <= X"0f";
            if i2sLeftRightSelect_Reg = '1' then
              waveTableIndex <= sampleIndex;
              modulation <= modulationValue;
              isSoundPlaying <= isSamplePlaying;
            end if;
          else
            bitCount <= bitCount - X"01";
          end if;
        end if;
      end if;
      noteSampleCount <= noteSampleCount + X"000001";
      if noteSampleCount >= noteSampleTicks then
        noteSampleCount <= X"000000";
        if isSamplePlaying = '1' then
          sampleIndex <= sampleIndex + X"01";
        else
          sampleIndex <= X"00";
        end if;
        if isNoteOn = '1' then
          isSamplePlaying <= '1';
        else
          if sampleIndex = X"00" then
            isSamplePlaying <= '0';
          end if;
        end if;
      end if;
    end if;
  end process;
end architecture;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Generated from Verilog module SampleMixer (SampleMixer.v:1)
entity SampleMixer is
  port (
    modulationValue : in unsigned(7 downto 0);
    renderedSample : out unsigned(15 downto 0);
    sample0 : in unsigned(15 downto 0);
    sample1 : in unsigned(15 downto 0);
    sample2 : in unsigned(15 downto 0)
  );
end entity; 

-- Generated from Verilog module SampleMixer (SampleMixer.v:1)
architecture from_verilog of SampleMixer is
  signal tmp_ivl_0 : unsigned(15 downto 0);  -- Temporary created at SampleMixer.v:73
  signal mixSample0 : unsigned(15 downto 0) := X"0000";  -- Declared at SampleMixer.v:9
  signal mixSample1 : unsigned(15 downto 0) := X"0000";  -- Declared at SampleMixer.v:10
  signal mixSample2 : unsigned(15 downto 0) := X"0000";  -- Declared at SampleMixer.v:11
begin
  tmp_ivl_0 <= mixSample0 + mixSample1;
  renderedSample <= tmp_ivl_0 + mixSample2;
  -- Removed one empty process
  
  
  -- Generated from always process in SampleMixer (SampleMixer.v:13)
  process (modulationValue, sample2, sample1, sample0) is
  begin
    if sample0(15) = '1' then
      if Resize(((not sample0) + X"0001"), 32) > ((((not sample0) + X"0001") srl 6) * Resize(modulationValue, 16)) then
        mixSample0 <= Resize((not (Resize(((not sample0) + X"0001"), 32) - ((((not sample0) + X"0001") srl 6) * Resize(modulationValue, 16)))) + X"00000001", 16);
      else
        mixSample0 <= X"0000";
      end if;
    else
      if Resize(sample0, 32) > ((sample0 srl 6) * Resize(modulationValue, 16)) then
        mixSample0 <= Resize(Resize(sample0, 32) - ((sample0 srl 6) * Resize(modulationValue, 16)), 16);
      else
        mixSample0 <= X"0000";
      end if;
    end if;
    if sample1(15) = '1' then
      if Resize(modulationValue, 32) >= X"00000040" then
        if Resize(((not sample1) + X"0001"), 32) > ((((not sample1) + X"0001") srl 6) * (Resize(modulationValue, 16) - X"0040")) then
          mixSample1 <= Resize((not (Resize(((not sample1) + X"0001"), 32) - ((((not sample1) + X"0001") srl 6) * (Resize(modulationValue, 16) - X"0040")))) + X"00000001", 16);
        else
          mixSample1 <= X"0000";
        end if;
      else
        if Resize(((not sample1) + X"0001"), 32) > ((((not sample1) + X"0001") srl 6) * (X"0040" - Resize(modulationValue, 16))) then
          mixSample1 <= Resize((not (Resize(((not sample1) + X"0001"), 32) - ((((not sample1) + X"0001") srl 6) * (X"0040" - Resize(modulationValue, 16))))) + X"00000001", 16);
        else
          mixSample1 <= X"0000";
        end if;
      end if;
    else
      if Resize(modulationValue, 32) >= X"00000040" then
        if Resize(sample1, 32) > ((sample1 srl 6) * (Resize(modulationValue, 16) - X"0040")) then
          mixSample1 <= Resize(Resize(sample1, 32) - ((sample1 srl 6) * (Resize(modulationValue, 16) - X"0040")), 16);
        else
          mixSample1 <= X"0000";
        end if;
      else
        if Resize(sample1, 32) > ((sample1 srl 6) * (X"0040" - Resize(modulationValue, 16))) then
          mixSample1 <= Resize(Resize(sample1, 32) - ((sample1 srl 6) * (X"0040" - Resize(modulationValue, 16))), 16);
        else
          mixSample1 <= X"0000";
        end if;
      end if;
    end if;
    if sample2(15) = '1' then
      if Resize(((not sample2) + X"0001"), 32) > ((((not sample2) + X"0001") srl 6) * (X"007f" - Resize(modulationValue, 16))) then
        mixSample2 <= Resize((not (Resize(((not sample2) + X"0001"), 32) - ((((not sample2) + X"0001") srl 6) * (X"007f" - Resize(modulationValue, 16))))) + X"00000001", 16);
      else
        mixSample2 <= X"0000";
      end if;
    else
      if Resize(sample2, 32) > ((sample2 srl 6) * (X"007f" - Resize(modulationValue, 16))) then
        mixSample2 <= Resize(Resize(sample2, 32) - ((sample2 srl 6) * (X"007f" - Resize(modulationValue, 16))), 16);
      else
        mixSample2 <= X"0000";
      end if;
    end if;
  end process;
end architecture;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Generated from Verilog module WaveTable0Rom (WaveTable0Rom_bb.v:34)
entity WaveTable0Rom is
  port (
    address : in unsigned(7 downto 0);
    clock : inout std_logic;
    q : out unsigned(15 downto 0)
  );
end entity; 

-- Generated from Verilog module WaveTable0Rom (WaveTable0Rom_bb.v:34)
architecture from_verilog of WaveTable0Rom is
begin
  clock <= '1';
  q <= (others => 'Z');
end architecture;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Generated from Verilog module WaveTable1Rom (WaveTable1Rom_bb.v:34)
entity WaveTable1Rom is
  port (
    address : in unsigned(7 downto 0);
    clock : inout std_logic;
    q : out unsigned(15 downto 0)
  );
end entity; 

-- Generated from Verilog module WaveTable1Rom (WaveTable1Rom_bb.v:34)
architecture from_verilog of WaveTable1Rom is
begin
  q <= (others => 'Z');
end architecture;

library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

-- Generated from Verilog module WaveTable2Rom (WaveTable2Rom_bb.v:34)
entity WaveTable2Rom is
  port (
    address : in unsigned(7 downto 0);
    clock : inout std_logic;
    q : out unsigned(15 downto 0)
  );
end entity; 

-- Generated from Verilog module WaveTable2Rom (WaveTable2Rom_bb.v:34)
architecture from_verilog of WaveTable2Rom is
begin
  q <= (others => 'Z');
end architecture;

