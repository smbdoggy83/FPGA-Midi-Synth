// -------------------------------------------------------------
//
// Module: BandpassFilter
// Generated by MATLAB(R) 9.11 and Filter Design HDL Coder 3.1.10.
// Generated on: 2022-04-20 10:27:30
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Code Generation Options:
//
// TargetDirectory: C:\Users\etimm\Documents\1A DSP
// Name: BandpassFilter
// TargetLanguage: Verilog
// TestBenchStimulus: step ramp chirp 

// Filter Specifications:
//
// Sample Rate            : N/A (normalized frequency)
// Response               : Bandpass
// Specification          : Fst1,Fp1,Fp2,Fst2,Ast1,Ap,Ast2
// Passband Ripple        : 1 dB
// First Stopband Edge    : 0.3
// First Passband Edge    : 0.4
// Second Stopband Atten. : 80 dB
// Second Stopband Edge   : 0.6
// First Stopband Atten.  : 60 dB
// Second Passband Edge   : 0.5
// -------------------------------------------------------------

// -------------------------------------------------------------
// HDL Implementation    : Fully parallel
// Folding Factor        : 1
// -------------------------------------------------------------
// Filter Settings:
//
// Discrete-Time IIR Filter (real)
// -------------------------------
// Filter Structure    : Direct-Form II, Second-Order Sections
// Number of Sections  : 6
// Stable              : Yes
// Linear Phase        : No
// -------------------------------------------------------------




`timescale 1 ns / 1 ns

module BandpassFilter
               (
                clk,
                clk_enable,
                reset,
                filter_in,
                filter_out
                );

  input   clk; 
  input   clk_enable; 
  input   reset; 
  input   [63:0] filter_in; //double
  output  [63:0] filter_out; //double

////////////////////////////////////////////////////////////////
//Module Architecture: BandpassFilter
////////////////////////////////////////////////////////////////
  // Local Functions
  // Type Definitions
  // Constants
  parameter scaleconst1 = 1.5425030276147506E-01; //double
  parameter coeff_b1_section1 = 1.0000000000000000E+00; //double
  parameter coeff_b2_section1 = 0.0000000000000000E+00; //double
  parameter coeff_b3_section1 = -1.0000000000000000E+00; //double
  parameter coeff_a2_section1 = -6.1043879153434211E-01; //double
  parameter coeff_a3_section1 = 9.8143197392794623E-01; //double
  parameter scaleconst2 = 1.5425030276147506E-01; //double
  parameter coeff_b1_section2 = 1.0000000000000000E+00; //double
  parameter coeff_b2_section2 = 0.0000000000000000E+00; //double
  parameter coeff_b3_section2 = -1.0000000000000000E+00; //double
  parameter coeff_a2_section2 = -2.0518171897815629E-03; //double
  parameter coeff_a3_section2 = 9.8049193191951722E-01; //double
  parameter scaleconst3 = 1.1446552288710127E-01; //double
  parameter coeff_b1_section3 = 1.0000000000000000E+00; //double
  parameter coeff_b2_section3 = 0.0000000000000000E+00; //double
  parameter coeff_b3_section3 = -1.0000000000000000E+00; //double
  parameter coeff_a2_section3 = -5.2501423372875955E-01; //double
  parameter coeff_a3_section3 = 9.4919123947884021E-01; //double
  parameter scaleconst4 = 1.1446552288710127E-01; //double
  parameter coeff_b1_section4 = 1.0000000000000000E+00; //double
  parameter coeff_b2_section4 = 0.0000000000000000E+00; //double
  parameter coeff_b3_section4 = -1.0000000000000000E+00; //double
  parameter coeff_a2_section4 = -8.4258749074382328E-02; //double
  parameter coeff_a3_section4 = 9.4734085645049726E-01; //double
  parameter scaleconst5 = 5.3904220469691733E-02; //double
  parameter coeff_b1_section5 = 1.0000000000000000E+00; //double
  parameter coeff_b2_section5 = 0.0000000000000000E+00; //double
  parameter coeff_b3_section5 = -1.0000000000000000E+00; //double
  parameter coeff_a2_section5 = -3.8540128220980258E-01; //double
  parameter coeff_a3_section5 = 9.2967910781566598E-01; //double
  parameter scaleconst6 = 5.3904220469691733E-02; //double
  parameter coeff_b1_section6 = 1.0000000000000000E+00; //double
  parameter coeff_b2_section6 = 0.0000000000000000E+00; //double
  parameter coeff_b3_section6 = -1.0000000000000000E+00; //double
  parameter coeff_a2_section6 = -2.2466742510226170E-01; //double
  parameter coeff_a3_section6 = 9.2875582287085512E-01; //double
  parameter scaleconst7 = 8.9125093813374556E-01; //double
  // Signals
  real input_register; // double
  real scale1; // double
  real scaletypeconvert1; // double
  // Section 1 Signals 
  real a1sum1; // double
  real a2sum1; // double
  real b1sum1; // double
  real delay_section1 [0:1] ; // double
  real inputconv1; // double
  real a2mul1; // double
  real a3mul1; // double
  real b1mul1; // double
  real b3mul1; // double
  real scale2; // double
  real scaletypeconvert2; // double
  // Section 2 Signals 
  real a1sum2; // double
  real a2sum2; // double
  real b1sum2; // double
  real delay_section2 [0:1] ; // double
  real inputconv2; // double
  real a2mul2; // double
  real a3mul2; // double
  real b1mul2; // double
  real b3mul2; // double
  real scale3; // double
  real scaletypeconvert3; // double
  // Section 3 Signals 
  real a1sum3; // double
  real a2sum3; // double
  real b1sum3; // double
  real delay_section3 [0:1] ; // double
  real inputconv3; // double
  real a2mul3; // double
  real a3mul3; // double
  real b1mul3; // double
  real b3mul3; // double
  real scale4; // double
  real scaletypeconvert4; // double
  // Section 4 Signals 
  real a1sum4; // double
  real a2sum4; // double
  real b1sum4; // double
  real delay_section4 [0:1] ; // double
  real inputconv4; // double
  real a2mul4; // double
  real a3mul4; // double
  real b1mul4; // double
  real b3mul4; // double
  real scale5; // double
  real scaletypeconvert5; // double
  // Section 5 Signals 
  real a1sum5; // double
  real a2sum5; // double
  real b1sum5; // double
  real delay_section5 [0:1] ; // double
  real inputconv5; // double
  real a2mul5; // double
  real a3mul5; // double
  real b1mul5; // double
  real b3mul5; // double
  real scale6; // double
  real scaletypeconvert6; // double
  // Section 6 Signals 
  real a1sum6; // double
  real a2sum6; // double
  real b1sum6; // double
  real delay_section6 [0:1] ; // double
  real inputconv6; // double
  real a2mul6; // double
  real a3mul6; // double
  real b1mul6; // double
  real b3mul6; // double
  real scale7; // double
  real output_typeconvert; // double
  real output_register; // double

  // Block Statements
  always @ (posedge clk or posedge reset)
    begin: input_reg_process
      if (reset == 1'b1) begin
        input_register <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          input_register <= $bitstoreal(filter_in);
        end
      end
    end // input_reg_process

  always @* scale1 <= input_register * scaleconst1;

  always @* scaletypeconvert1 <= scale1;


  //   ------------------ Section 1 ------------------

  always @ (posedge clk or posedge reset)
    begin: delay_process_section1
      if (reset == 1'b1) begin
        delay_section1[0] <= 0.0000000000000000E+00;
        delay_section1[1] <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section1[1] <= delay_section1[0];
          delay_section1[0] <= a1sum1;
        end
      end
    end // delay_process_section1

  always @* inputconv1 <= scaletypeconvert1;


  always @* a2mul1 <= delay_section1[0] * coeff_a2_section1;

  always @* a3mul1 <= delay_section1[1] * coeff_a3_section1;

  always @* b1mul1 <= a1sum1;


  always @* b3mul1 <= -delay_section1[1];

  always @* a2sum1 <= inputconv1 - a2mul1;

  always @* a1sum1 <= a2sum1 - a3mul1;

  always @* b1sum1 <= b1mul1 + b3mul1;

  always @* scale2 <= b1sum1 * scaleconst2;

  always @* scaletypeconvert2 <= scale2;


  //   ------------------ Section 2 ------------------

  always @ (posedge clk or posedge reset)
    begin: delay_process_section2
      if (reset == 1'b1) begin
        delay_section2[0] <= 0.0000000000000000E+00;
        delay_section2[1] <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section2[1] <= delay_section2[0];
          delay_section2[0] <= a1sum2;
        end
      end
    end // delay_process_section2

  always @* inputconv2 <= scaletypeconvert2;


  always @* a2mul2 <= delay_section2[0] * coeff_a2_section2;

  always @* a3mul2 <= delay_section2[1] * coeff_a3_section2;

  always @* b1mul2 <= a1sum2;


  always @* b3mul2 <= -delay_section2[1];

  always @* a2sum2 <= inputconv2 - a2mul2;

  always @* a1sum2 <= a2sum2 - a3mul2;

  always @* b1sum2 <= b1mul2 + b3mul2;

  always @* scale3 <= b1sum2 * scaleconst3;

  always @* scaletypeconvert3 <= scale3;


  //   ------------------ Section 3 ------------------

  always @ (posedge clk or posedge reset)
    begin: delay_process_section3
      if (reset == 1'b1) begin
        delay_section3[0] <= 0.0000000000000000E+00;
        delay_section3[1] <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section3[1] <= delay_section3[0];
          delay_section3[0] <= a1sum3;
        end
      end
    end // delay_process_section3

  always @* inputconv3 <= scaletypeconvert3;


  always @* a2mul3 <= delay_section3[0] * coeff_a2_section3;

  always @* a3mul3 <= delay_section3[1] * coeff_a3_section3;

  always @* b1mul3 <= a1sum3;


  always @* b3mul3 <= -delay_section3[1];

  always @* a2sum3 <= inputconv3 - a2mul3;

  always @* a1sum3 <= a2sum3 - a3mul3;

  always @* b1sum3 <= b1mul3 + b3mul3;

  always @* scale4 <= b1sum3 * scaleconst4;

  always @* scaletypeconvert4 <= scale4;


  //   ------------------ Section 4 ------------------

  always @ (posedge clk or posedge reset)
    begin: delay_process_section4
      if (reset == 1'b1) begin
        delay_section4[0] <= 0.0000000000000000E+00;
        delay_section4[1] <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section4[1] <= delay_section4[0];
          delay_section4[0] <= a1sum4;
        end
      end
    end // delay_process_section4

  always @* inputconv4 <= scaletypeconvert4;


  always @* a2mul4 <= delay_section4[0] * coeff_a2_section4;

  always @* a3mul4 <= delay_section4[1] * coeff_a3_section4;

  always @* b1mul4 <= a1sum4;


  always @* b3mul4 <= -delay_section4[1];

  always @* a2sum4 <= inputconv4 - a2mul4;

  always @* a1sum4 <= a2sum4 - a3mul4;

  always @* b1sum4 <= b1mul4 + b3mul4;

  always @* scale5 <= b1sum4 * scaleconst5;

  always @* scaletypeconvert5 <= scale5;


  //   ------------------ Section 5 ------------------

  always @ (posedge clk or posedge reset)
    begin: delay_process_section5
      if (reset == 1'b1) begin
        delay_section5[0] <= 0.0000000000000000E+00;
        delay_section5[1] <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section5[1] <= delay_section5[0];
          delay_section5[0] <= a1sum5;
        end
      end
    end // delay_process_section5

  always @* inputconv5 <= scaletypeconvert5;


  always @* a2mul5 <= delay_section5[0] * coeff_a2_section5;

  always @* a3mul5 <= delay_section5[1] * coeff_a3_section5;

  always @* b1mul5 <= a1sum5;


  always @* b3mul5 <= -delay_section5[1];

  always @* a2sum5 <= inputconv5 - a2mul5;

  always @* a1sum5 <= a2sum5 - a3mul5;

  always @* b1sum5 <= b1mul5 + b3mul5;

  always @* scale6 <= b1sum5 * scaleconst6;

  always @* scaletypeconvert6 <= scale6;


  //   ------------------ Section 6 ------------------

  always @ (posedge clk or posedge reset)
    begin: delay_process_section6
      if (reset == 1'b1) begin
        delay_section6[0] <= 0.0000000000000000E+00;
        delay_section6[1] <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          delay_section6[1] <= delay_section6[0];
          delay_section6[0] <= a1sum6;
        end
      end
    end // delay_process_section6

  always @* inputconv6 <= scaletypeconvert6;


  always @* a2mul6 <= delay_section6[0] * coeff_a2_section6;

  always @* a3mul6 <= delay_section6[1] * coeff_a3_section6;

  always @* b1mul6 <= a1sum6;


  always @* b3mul6 <= -delay_section6[1];

  always @* a2sum6 <= inputconv6 - a2mul6;

  always @* a1sum6 <= a2sum6 - a3mul6;

  always @* b1sum6 <= b1mul6 + b3mul6;

  always @* scale7 <= b1sum6 * scaleconst7;

  always @* output_typeconvert <= scale7;


  always @ (posedge clk or posedge reset)
    begin: Output_Register_process
      if (reset == 1'b1) begin
        output_register <= 0.0000000000000000E+00;
      end
      else begin
        if (clk_enable == 1'b1) begin
          output_register <= output_typeconvert;
        end
      end
    end // Output_Register_process

  // Assignment Statements
  assign filter_out = $realtobits(output_register);
endmodule  // BandpassFilter
