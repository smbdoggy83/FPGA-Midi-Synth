
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module DE10_Standard_i2sound(

	//////////// CLOCK //////////
	input 		          		CLOCK2_50,
	input 		          		CLOCK3_50,
	input 		          		CLOCK4_50,
	input 		          		CLOCK_50,

	//////////// KEY //////////
	input 		     [3:0]		KEY,

	//////////// SW //////////
	input 		     [9:0]		SW,

	//////////// LED //////////
	output		     [9:0]		LEDR,

	//////////// Seg7 //////////
	output		     [6:0]		HEX0,
	output		     [6:0]		HEX1,
	output		     [6:0]		HEX2,
	output		     [6:0]		HEX3,
	output		     [6:0]		HEX4,
	output		     [6:0]		HEX5,

	//////////// SDRAM //////////
	output		    [12:0]		DRAM_ADDR,
	output		     [1:0]		DRAM_BA,
	output		          		DRAM_CAS_N,
	output		          		DRAM_CKE,
	output		          		DRAM_CLK,
	output		          		DRAM_CS_N,
	inout 		    [15:0]		DRAM_DQ,
	output		          		DRAM_LDQM,
	output		          		DRAM_RAS_N,
	output		          		DRAM_UDQM,
	output		          		DRAM_WE_N,

	//////////// Video-In //////////
	input 		          		TD_CLK27,
	input 		     [7:0]		TD_DATA,
	input 		          		TD_HS,
	output		          		TD_RESET_N,
	input 		          		TD_VS,

	//////////// VGA //////////
	output		          		VGA_BLANK_N,
	output		     [7:0]		VGA_B,
	output		          		VGA_CLK,
	output		     [7:0]		VGA_G,
	output		          		VGA_HS,
	output		     [7:0]		VGA_R,
	output		          		VGA_SYNC_N,
	output		          		VGA_VS,

	//////////// Audio //////////
	input 		          		AUD_ADCDAT,
	inout 		          		AUD_ADCLRCK,
	inout 		          		AUD_BCLK,
	output		          		AUD_DACDAT,
	inout 		          		AUD_DACLRCK,
	output		          		AUD_XCK,

	//////////// PS2 //////////
	inout 		          		PS2_CLK,
	inout 		          		PS2_CLK2,
	inout 		          		PS2_DAT,
	inout 		          		PS2_DAT2,

	//////////// ADC //////////
	output		          		ADC_CONVST,
	output		          		ADC_DIN,
	input 		          		ADC_DOUT,
	output		          		ADC_SCLK,

	//////////// I2C for Audio and Video-In //////////
	output		          		FPGA_I2C_SCLK,
	inout 		          		FPGA_I2C_SDAT,

	//////////// IR //////////
	input 		          		IRDA_RXD,
	output		          		IRDA_TXD
);



///=======================================================
//  REG/WIRE declarations
//=======================================================
wire				CLK_1M;
wire			 	END;
wire			 	KEY0_EDGE;
wire	[23:0] 		AUD_I2C_DATA;
wire         		GO;
wire  	[3:0]  		level_vol;

//=======================================================
//  Structural coding
//=======================================================
assign		LEDR = 10'h000;
assign		HEX1 = 7'h40;
assign		AUD_DACDAT = AUD_ADCDAT
;

//KEY triggle
keytr			u3(
	.clock(CLK_1M),
	.key0(KEY[0]),
	.rst_n(KEY[1]),
	
	.KEY0_EDGE(KEY0_EDGE)
	);

//I2C output data
CLOCK_500		u1(
	.CLOCK(CLOCK_50),
	.rst_n(KEY[1]),					 
	.END(END),
	.KEY0_EDGE(KEY0_EDGE),
	
	.CLOCK_500(CLK_1M),
	.GO(GO),             
	.CLOCK_2(AUD_XCK),
	.DATA(AUD_I2C_DATA),
	.level_vol(level_vol)
	);
					 
//i2c controller
i2c				u2( 
	// Host Side
	.CLOCK(CLK_1M),
	.RESET(1'b1),
	// I2C Side
	.I2C_SDAT(FPGA_I2C_SDAT),
	.I2C_DATA(AUD_I2C_DATA),
	.I2C_SCLK(FPGA_I2C_SCLK),
	// Control Signals
	.GO(GO),
	.END(END)
	);
					 
HEX				u4(
	.hex(level_vol),
	.hex_fps(HEX0)
	);



endmodule


`define rom_size 6'd8

module CLOCK_500(
	CLOCK,
	rst_n,
	END,
	KEY0_EDGE,
	
	DATA,
	GO,
	level_vol,				  
	CLOCK_500,				  
	CLOCK_2
	);
//=======================================================
//  PORT declarations
//=======================================================                
input  		 	CLOCK;
input 		 	rst_n;
input 		 	END;
input 		 	KEY0_EDGE;

output 	[23:0]	DATA;
output 			GO;
output	[3:0] 	level_vol;
output		    CLOCK_500;
output 			CLOCK_2;


reg  	[10:0]	COUNTER_500;
reg  	[15:0]	ROM[`rom_size:0];
reg  	[15:0]	DATA_A;
reg  	[5:0]	address;




wire  CLOCK_500 = COUNTER_500[9];
wire  CLOCK_2 	= COUNTER_500[1];

wire [23:0]DATA = {8'h34, DATA_A};		//slave address + sub_address + register_data
wire  GO = ((address <= `rom_size) && (END == 1)) ? COUNTER_500[10] : 1;
//=============================================================================
// Structural coding
//=============================================================================

always @(posedge CLOCK ) 
begin
	COUNTER_500=COUNTER_500+1;
end


always @(negedge KEY0_EDGE or posedge END) 
begin
	if (!KEY0_EDGE)
	begin
		address=0;
	end
	else if (address <= `rom_size)
	begin
		address=address+1;
	end
end

reg		[4:0]	vol;
wire	[6:0]	volume;

always @(negedge KEY0_EDGE or negedge rst_n) 
begin
	if(!rst_n)
		vol = 5'd31;
	else if(vol == 5'd4)
		vol = 5'd31;
	else if(!KEY0_EDGE)
		vol = vol - 3;
end

//the volume level, level 0 to level 9,
//the higher the level, the greater the sound
assign level_vol = (vol - 4) / 3;
assign volume = vol + 96;


always @(posedge END) 
begin
	ROM[0] = 16'h0c00;	    			 	//power down
	ROM[1] = 16'h0ec2;	   		    	 	//master
	ROM[2] = 16'h0838;	    			 	//sound select
	
	ROM[3] = 16'h1000;						//mclk
	
	ROM[4] = 16'h0017;						//
	ROM[5] = 16'h0217;					 	//
	ROM[6] = {8'h04,1'b0,volume[6:0]};		//left channel headphone output volume
	ROM[7] = {8'h06,1'b0,volume[6:0]};		//right channel headphone output volume
	
	//ROM[4]= 16'h1e00;		             	//reset	
	ROM[`rom_size] = 16'h1201;           	//active
	DATA_A = ROM[address];
end


endmodule

module  HEX(
input	[3:0]	hex,
output	[6:0]	hex_fps
);


assign hex_fps	=	(hex == 4'd0) ? 7'h40: //0
					(hex == 4'd1) ? 7'h79: //1
					(hex == 4'd2) ? 7'h24: //2
					(hex == 4'd3) ? 7'h30: //3
					(hex == 4'd4) ? 7'h19: //4        
					(hex == 4'd5) ? 7'h12: //5
					(hex == 4'd6) ? 7'h02: //6
					(hex == 4'd7) ? 7'h78: //7
					(hex == 4'd8) ? 7'h00: //8
									7'h10; //9

endmodule 


module i2c (
			 CLOCK,
			 I2C_SCLK,		//I2C CLOCK
			 I2C_SDAT,		//I2C DATA
			 I2C_DATA,		//DATA:[SLAVE_ADDR,SUB_ADDR,DATA]
			 GO,      		//GO transfor
			 END,    	    //END transfor 
			 W_R,     		//W_R
			 ACK,     	    //ACK
			 RESET,
			 //TEST
			 SD_COUNTER,
			 SDO
		   	);

//=======================================================
//  PORT declarations
//=======================================================
			
	input 			 CLOCK;
	input 			 [23:0]I2C_DATA;	
	input 			 GO;
	input  			 RESET;	
	input  			 W_R;
	
 	inout  			 I2C_SDAT;
 		
	output 			 I2C_SCLK;
	output			 END;	
	output 			 ACK;

//TEST
	output	[5:0]	 SD_COUNTER;
	output 			 SDO;


	reg 			 SDO;
	reg 			 SCLK;
	reg 			 END;
	reg 	[23:0]	 SD;
	reg 	[5:0]	 SD_COUNTER;

wire I2C_SCLK = SCLK | ( ((SD_COUNTER >= 4) & (SD_COUNTER <= 30))? ~CLOCK :0 );
wire I2C_SDAT = SDO?1'bz:0 ;

reg ACK1,ACK2,ACK3;
wire ACK = ACK1 | ACK2 | ACK3;

//=============================================================================
// Structural coding
//=============================================================================

//==============================I2C COUNTER====================================
always @(negedge RESET or posedge CLOCK ) 
	begin
		if (!RESET)
			begin
				SD_COUNTER = 6'b111111;
			end
		else begin
				if (GO == 0)
					begin
						SD_COUNTER = 0;
					end
				else begin
						if (SD_COUNTER < 6'b111111)
							begin
								SD_COUNTER = SD_COUNTER+1;
							end	
					 end		
			 end
	end
//==============================I2C COUNTER====================================

always @(negedge RESET or  posedge CLOCK ) 
	begin
		if (!RESET) 
			begin 
				SCLK = 1;
				SDO  = 1; 
				ACK1 = 0;
				ACK2 = 0;
				ACK3 = 0; 
				END  = 1; 
			end
		else
			case (SD_COUNTER)
					6'd0  : begin 
								ACK1 = 0 ;
								ACK2 = 0 ;
								ACK3 = 0 ; 
								END  = 0 ; 
								SDO  =1  ; 
								SCLK =1  ;
							end
					//=========start===========
					6'd1  : begin 
								SD  = I2C_DATA;
								SDO = 0;
							end
							
					6'd2  : 	SCLK = 0;
					//======SLAVE ADDR=========
					6'd3  : 	SDO = SD[23];
					6'd4  : 	SDO = SD[22];
					6'd5  : 	SDO = SD[21];
					6'd6  : 	SDO = SD[20];
					6'd7  : 	SDO = SD[19];
					6'd8  : 	SDO = SD[18];
					6'd9  :	    SDO	= SD[17];
					6'd10 : 	SDO = SD[16];	
					6'd11 : 	SDO = 1'b1;//ACK

					//========SUB ADDR==========
					6'd12  : begin 
								SDO  = SD[15]; 
								ACK1 = I2C_SDAT; 
							 end
					6'd13  : 	SDO = SD[14];
					6'd14  : 	SDO = SD[13];
					6'd15  : 	SDO = SD[12];
					6'd16  : 	SDO = SD[11];
					6'd17  : 	SDO = SD[10];
					6'd18  : 	SDO = SD[9];
					6'd19  : 	SDO = SD[8];	
					6'd20  : 	SDO = 1'b1;//ACK

					//===========DATA============
					6'd21  : begin 
								SDO  = SD[7]; 
								ACK2 = I2C_SDAT; 
							 end
					6'd22  : 	SDO = SD[6];
					6'd23  : 	SDO = SD[5];
					6'd24  : 	SDO = SD[4];
					6'd25  : 	SDO = SD[3];
					6'd26  : 	SDO = SD[2];
					6'd27  : 	SDO = SD[1];
					6'd28  : 	SDO = SD[0];	
					6'd29  : 	SDO = 1'b1;//ACK

	
					//stop
					6'd30 : begin 
								SDO  = 1'b0;	
								SCLK = 1'b0; 
								ACK3 = I2C_SDAT; 
							end	
					6'd31 : 	SCLK = 1'b1; 
					6'd32 : begin 
								SDO = 1'b1; 
								END = 1; 
							end 

			endcase
	end
	
endmodule


//`define  OUT_BIT  9

module keytr(
	key0,
	rst_n,
	clock,
	
	ON,				
	KEY0_EDGE,
	counter	
	);

//=======================================================
//  PORT declarations
//=======================================================			 
input			key0;
input			rst_n;
input			clock;

output			ON;
output			KEY0_EDGE;
output	[9:0]	counter;

reg     [9:0]  counter;
//reg              KEYON;
//wire ON=((counter[`OUT_BIT]==1) && (key==0))?0:1; 
/*/=============================================================================
// Structural coding
//=============================================================================
always @(negedge ON or posedge clock) 
	begin
		if (!ON)
			begin
				counter=0;
			end 
		else if (counter[`OUT_BIT]==0)
				begin
					counter=counter+1;
				end	
	end

always @(posedge clock) 
	begin
		if  ((counter>=1) && (counter <5))
			begin
				KEYON=0;
			end
		else begin	
				KEYON=1;
			 end
	end*/

///debounce starts

reg		[3:0]	flag_temp;
reg				flag;
reg		[15:0]	delay;
reg				D1;
reg 			D2;
wire			falling_edge;


//falling edge detect,
always@(negedge clock)
begin
  if (flag)
  begin 
     flag_temp<={key0, flag_temp[3:1]};
  end 
end
assign falling_edge = (flag_temp==4'b0011) ? 1'b1 : 1'b0;


////////////
always@(posedge clock,negedge rst_n)
begin
  if (!rst_n)
     flag <= 1'b1;
  else if (delay == 15'd4096)////modify the value here for a better debounce effect when using a high clock frequency;
     flag <= 1'b1;
  else if (falling_edge)
     flag <= 1'b0;
end



//
always@(posedge clock)
begin
  if (!key0)
     delay <= delay+1;
  else
     delay <= 15'd0;
end



///debounce over!
/////////////////////////////////////////
///////////?????
always@(negedge clock)
begin
  D1 <= flag;
  D2 <= D1;
end
assign KEY0_EDGE = (D1 | !D2);

endmodule	
	
